package cn.itsource.polymorphic2;

/**
 *	多态测试类2
 *	
 *	3.1 向上造型
		语法：
			父类类型 对象名 = new 子类类型(...);// 向上造型【只能调用父类中声明的方法，不能调用子类特有方法】
			对象名.方法();// 如果子类重写了方法，则会执行对应子类重写后的方法
			多态调用的方法，但是父类中有的方法，不能调用子类特有方法
			【这里主要是看对象中装的是哪一个子类，装的是哪一个就执行这一个重写后的】
		
			如果调用子类特有方法，就必须要向下造型，向下造型前，必须进行类型判断
			
		3.2 向下造型 => 就是强制类型转换
			强制类型转换语法：
				子类类型 变量 = (子类类型)父类变量/父类类型值;
			
			因为不能确定父类变量中装的是哪一个子类对象，所以应该先进行类型判断，
		 	在确定对应的类型后，再进行强制转换：
		 	
		 	类型判断语法1 ：
		 		if(父类变量名 instanceof 子类类型1){
		 			// 强制转换
		 			子类类型1 变量 = (子类类型1)父类变量/父类类型值;
		 			
		 			// 调用子类特有方法
		 			子类变量.特有方法(...);
		 		} else if(父类变量名 instanceof 子类类型2){
		 			// 强制转换
		 			子类类型2 变量 = (子类类型2)父类变量/父类类型值;
		 			// 调用子类特有方法
		 			子类变量.特有方法(...);
		 		}...
		
		 	类型判断语法2 ：
		 		if(父类变量名.getClass() == 子类类型1.class){
		 			// 强制转换
		 			子类类型1 变量 = (子类类型1)父类变量/父类类型值;
		 			
		 			// 调用子类特有方法
		 			子类变量.特有方法(...);
		 		} else if(父类变量名.getClass() == 子类类型2.class){
		 			// 强制转换
		 			子类类型2 变量 = (子类类型2)父类变量/父类类型值;
		 			
		 			// 调用子类特有方法
		 			子类变量.特有方法(...);
		 		}...
		
 */
public class AnimalTest {

	public static void main(String[] args) {
		// 创建子类Person对象，装到父类Animal变量p中
		Animal p = new Person();// 向上造型【向上转型】
		// 对象p调用方法eat
		p.eat();// 吃大肠刺身...【执行的是子类Person重写后的方法】
		// 对象p调用子类Person特有方法：coding
//		p.coding();// 向上造型不能调用子类特有方法，只能调用父类中和祖宗类中有的方法
		// 如果就要调用子类Person特有方法：coding，就必须向下造型【强制转换】
		/*
		 * 向下造型【强制转换】，语法：子类类型 变量 = (子类类型)值/父类变量;
		 */
		Person person = (Person)p;
		// 用person调用特有方法：coding
		person.coding();
		
		// 创建子类Pig对象，装到父类Animal变量p2中
		Animal p2 = new Pig();// 向上造型【向上转型】
		// 对象p2调用方法eat
		p2.eat();// 吃白菜...【执行的是子类Person重写后的方法】
		// 对象p调用子类Pig特有方法：gongBaiCai
//		p2.gongBaiCai();// 向上造型不能调用子类特有方法，只能调用父类中和祖宗类中有的方法
		// 如果就要调用子类Pig特有方法：gongBaiCai，就必须向下造型【强制转换】
		/*
		 * 向下造型【强制转换】，语法：子类类型 变量 = (子类类型)值/父类变量;
		 */
		Pig pig = (Pig)p2;
		// 用pig调用特有方法：gongBaiCai
		pig.gongBaiCai();
		
		// 调用看左边，运行看右边,就是指能够通过对象.出来哪些
		System.out.println(p2.age);// 1
		
	}

}
