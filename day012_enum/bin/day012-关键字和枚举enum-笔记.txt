day012-关键字和枚举enum-笔记

2. 多态(polymorphic)(重点)
	1. 概念：就是创建对象的时候用父类变量装子类对象【向上造型】
			当父类变量调用方法的时候，如果子类重写了方法，则会执行对应子类重写后的方法。
			官方说法:当编译时类型和运行时类型不一致的时候，就产生了多态。
	2. 作用：
			1. 提高的程序开发的扩展性和灵活性。
			2. 让代码更简洁，更健壮。
-----------------------3. 使用：（最重要）-------------------------------
3. 使用：（最重要）
		3.1 向上造型
		语法：
			父类类型 对象名 = new 子类类型(...);// 向上造型【只能调用父类中声明的方法，不能调用子类特有方法】
			对象名.方法();// 如果子类重写了方法，则会执行对应子类重写后的方法
			多态调用的方法，但是父类中有的方法，不能调用子类特有方法
			【这里主要是看对象中装的是哪一个子类，装的是哪一个就执行这一个重写后的】
		
			如果调用子类特有方法，就必须要向下造型，向下造型前，必须进行类型判断
			
		3.2 向下造型 => 就是强制类型转换
			强制类型转换语法：
				子类类型 变量 = (子类类型)父类变量/父类类型值;
			
			因为不能确定父类变量中装的是哪一个子类对象，所以应该先进行类型判断，
		 	在确定对应的类型后，再进行强制转换：
		 	
		 	类型判断语法1 ：
		 		if(父类变量名 instanceof 子类类型1){
		 			// 强制转换
		 			子类类型1 变量 = (子类类型1)父类变量/父类类型值;
		 			
		 			// 调用子类特有方法
		 			子类变量.特有方法(...);
		 		} else if(父类变量名 instanceof 子类类型2){
		 			// 强制转换
		 			子类类型2 变量 = (子类类型2)父类变量/父类类型值;
		 			// 调用子类特有方法
		 			子类变量.特有方法(...);
		 		}...
		
		 	类型判断语法2 ：
		 		if(父类变量名.getClass() == 子类类型1.class){
		 			// 强制转换
		 			子类类型1 变量 = (子类类型1)父类变量/父类类型值;
		 			
		 			// 调用子类特有方法
		 			子类变量.特有方法(...);
		 		} else if(父类变量名.getClass() == 子类类型2.class){
		 			// 强制转换
		 			子类类型2 变量 = (子类类型2)父类变量/父类类型值;
		 			
		 			// 调用子类特有方法
		 			子类变量.特有方法(...);
		 		}...
		
-------------------------------------------------------------------
	
	4. 注意事项：调用看左边，运行看右边
		4.1. 成员变量没有多态
		
		4.2. 多态不能调用子类特有的方法，如果需要调用子类特有的方法，
			必须进行强制类型转换（向下造型/向下转型），
			向下造型需要进行子类类型判断，否则，
			会报错：ClassCastException 类造型异常
			
	  	4.3. 父类变量能点（调用）出哪些成员（成员变量和方法），
	  	是由当前类和其父类决定,优先从当前类开始查找，
	  	直到找到Object了为止，如果Object中有没有，就不能调用
	  	

1.static修饰符（掌握使用场景）
	1. 概念：修饰符，表示静态的。用来修饰类和类中的成员的
	2. 作用：被其修饰的成员，都会在类加载的时候，加载到静态区中（预加载），只有一份。
		会被以该类创建的对象所共享。
		
	3. 使用：（将类中所有成员写出来，然后分别用static修饰看看，会不会报错，如果不报错，再看看修饰后的效果即可）
		能修饰：
			成员变量，被其修饰的成员变量叫 ： 类变量（字段：类变量、成员变量）
			成员方法：可以类方法
			内部类
			
		不能修饰：
			外部类
			构造方法
			局部变量
	
	4. 使用场景：（掌握）
		1. 需要几个对象共享成员变量或者成员方法的时候
		2. 需要预加载的时候，例如单例模式
		3. 不需要频繁创建对象的时候,可以用static修饰
		4. 一般配合public static final一起使用，表示全局常量
			要求，全大写，用_隔开，声明的同时必须赋值。
			例如：Math.PI、int最大值、最小值
		5. 修饰方法：为了简化调用过程。 

2. final修饰符（掌握）
	1  final概念
			关键字，修饰符，表示最终的。就是一旦修饰一个成员，该成员就不能再被修改了。 
	2  final作用：
			不想被其他程序员修改代码，用final
	3. 使用：		
			可以修饰：
				外部类：太监类，不能被继承
	 			实例变量：必须在声明的时候赋值或者在构造方法中赋值
				类变量： 必须在声明的时候赋值 
				实例方法：不能被子类重写				
	 			类方法：不能被子类重写
	 			内部类：
				局部变量：
			不能修饰：
 				构造方法
		
	4. 使用场景：（掌握）
		1. 不想被他人修改代码就用final
		2. final修饰的成员变量都是常量，在常量池中。


3. 内部类（理解） 组合关系
	1. 概念：内部类，把一个类定义在另一个类的内部，把里面的类称之为内部类，把外面的类称之为外部 
		类。（能认识内部类即可） 		
	2. 作用：更好的体现封装。不允许，其他的类使用内部类
	3. 使用：
		1. 实例内部类【没有static修饰的内部类】
		2. 静态内部类（比较常用）【static修饰的内部类】
		
4. 匿名内部类  Anonymous Inner Class（掌握）
	使用一个接口或者抽象类的时候，传统做法是写一个类实现该接口或者是继承该抽象类
	但是，如果当前实现类对象只使用一次，再去设计这个实现类，就会比较麻烦，
	这时候可以使用匿名内部类来简化设计类的工作。其实就是将 设计实现类的工作交给编译器完成。
	
	匿名内部类：就是将设计子类和创建子类对象的过程合二为一了，交给了编译器完成。这个时候，子类名字是编译器命名的，我们不知道，
		所以就是匿名内部类
	
	匿名内部类语法：（掌握）
	接口名/抽象类名 父类变量 = new 接口/抽象类() {//这里是多态的方式接受子类对象（这个子类的名字我们不知道，是编译器起的名字）
		//重写全部抽象方法
	};
	
	父类变量.抽象方法名(...);
	
5. 代码块：（了解）
	1. 概念：简单的认为就是一对大括号 {} 
	2. 特点： 作用域问题
	3. 代码块分类：
		3.1 静态代码块 （偶尔会用）
			语法：直接声明在类中，并且前面有static修饰
			class Xxx{
				//静态代码块
				static {
					//一般写一些初始化操作，例如，加载驱动
					//类加载的时候执行，执行一次
				}
			}	

		3.2 构造代码块 （一般不用）(了解)
			语法：直接声明在类中，并且前面没有static修饰
			class Xxx{
				//构造代码块
				{
					//会在创建的对象的时候，将该构造代码块中的内容复制到
					构造方法中，在super()下面
					每次创建对象都会执行一次
				}
			}	
			
		3.3 普通代码块 （基本不用，用的时候配合if或者循环使用）(了解)
			在方法中写一个{}，基本不用，用的时候配合if或者循环使用
		
		
	4. 执行流程：(了解)
			从静态代码块开始执行，然后是构造代码块，然后是构造方法
			
	5. 有继承关系的代码块执行流程：(了解)
		从最高父类的静态代码块开始加载，然后逐级向下加载，直到加载到
		当前类的静态代码块结束。再从最高父类的构造代码块开始执行，然后是构造方法，
		然后逐级向下执行，直到执行到当前类的构造代码块、构造方法结束。		
					
6. 枚举enum (重点掌握)
	1. 概念：就是一种跟类平级的新结构，适用于类中常量取值比较固定的场景
	2. 作用：就是简化类中全局常量这种代码
	3. 语法：
		 声明语法：(掌握)
			public enum 枚举类名Enum {
				字段（全大写、下划线。简化的就是全局常量）
				实例变量（尽量是private final修饰的）
				实例方法
				类方法【一般不会使用】
				构造方法 - 枚举中的构造方法默认都是private修饰，不能够是public，protected修饰
					构造方法作用：只能在当前枚举类中使用，就是给当前枚举类对象初始化实例变量的
			}
	
	4. 注意：
		4.1. 字段之间用逗号，最后一个字段用分号结束，且每个字段占一行。
		4.2. 可以写中文字段，但是不建议
		4.3. 枚举类都会隐式继承了Enum类（所有枚举类的基类），不能显示写出extends来
		4.4. 构造方法必须是private的
		4.5. 实例变量只能写在字段下
		
	5. 使用场景：(掌握)
		适用于一些取值固定的情况。例如：Vip、性别、QQ状态、星座、季节。。。。
			
	6. 枚举使用一般，只会使用字段，而不会去用枚举调用方法		
			
			
		
		
		