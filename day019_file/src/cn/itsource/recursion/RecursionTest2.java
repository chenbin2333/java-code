package cn.itsource.recursion;

/**
 *	2. 递归recursion：【理解】
	1. 概念：是一种思想,也是一种算法。在方法内部调用自己的方法。（自己干自己）
	
	2. 作用：就是简化有相似的业务逻辑（循环）代码。
	
	3. 使用规律特点：
		1. 通过数值带入的方式，查找逻辑规律：	将所有的已知条件写出来
 				就是有相似运算逻辑的代码
 		2. 通过条件判断（条件/循环）的方式，在满足条件的时候根据规律调用自己的方法。
 			如果不满足就不会自己的方法，这就是出口
	
	4. 使用场景：
		1. 树状结构数据、菜单结构、上下级关系等的数据查询
 		2. 有相似逻辑运算的结构
 		3. 适用于层级结构少，数据量小的场景。（最重要）如果层级多，且数据量大用循环。
	
	5.  解决了哪些问题：
		(1)数据的定义是按递归定义的。（Fibonacci函数：斐波拉契数列）
 		(2)问题解法按递归算法实现。(汉诺塔问题)
 			这类问题虽则本身没有明显的递归结构，但用递归求解比迭代求解更简单，如Hanoi问题。
 		(3)数据的结构形式是按递归定义的。
 			如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述。
	
	6. 注意事项：
		1. 递归必须 有出口
 		2. 能用循环用循环，不要用递归，因为效率极其低下。
 			为什么效率低下？
 				方法的调用都是创建新栈帧，入栈，而栈层级是有限制的
 			StackOverflowError : 栈内存溢出错误。
 */
public class RecursionTest2 {

	public static void main(String[] args) {
		// 需求：已知当前数字如下：1, 1, 2, 3, 5, 8..........，求第n个数字的值。设计方法实现。
		int fn = fn(10);
		System.out.println(fn);
	}
	
	/**
	 * 斐波拉契数列
	 * 分析：
		1. 通过数值带入的方式，将所有的已知条件写出来,查找逻辑规律[就是有相似运算逻辑的代码]：
 			n = 1,fn(1) = 1 
 			n = 2,fn(2) = 1
 			n = 3,fn(3) = 2 => fn(3) = fn(2) + fn(1);
 			n = 4,fn(4) = 3 => fn(4) = fn(3) + fn(2);
 			n = 5,fn(5) = 5 => fn(5) = fn(4) + fn(3);
 			..
 			n = n  fn(n) = fn(n-1) + fn(n-2);
 				
 		2. 通过条件判断（条件/循环）的方式，在满足条件的时候根据规律调用自己的方法。
 			如果不满足就不会自己的方法，这就是出口
	 * 
	 * @param n
	 * @return 返回第n个的值
	 */
	public static int fn(int n) {
		// 1. 通过数值带入的方式，将所有的已知条件写出来,
		if (n == 1 || n == 2) {
			return 1;
		} else {// 2. 通过条件判断（条件/循环）的方式，在满足条件的时候根据规律调用自己的方法
			return fn(n-1) + fn(n-2);
		}
	}

}
