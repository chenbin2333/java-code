package cn.itsource.recursion;

/**
 *	2. 递归recursion：【理解】
	1. 概念：是一种思想,也是一种算法。在方法内部调用自己的方法。（自己干自己）
	
	2. 作用：就是简化有相似的业务逻辑（循环）代码。
	
	3. 使用规律特点：
		1. 通过数值带入的方式，查找逻辑规律：	将所有的已知条件写出来
 				就是有相似运算逻辑的代码
 		2. 通过条件判断（条件/循环）的方式，在满足条件的时候根据规律调用自己的方法。
 			如果不满足就不会自己的方法，这就是出口
	
	4. 使用场景：
		1. 树状结构数据、菜单结构、上下级关系等的数据查询
 		2. 有相似逻辑运算的结构
 		3. 适用于层级结构少，数据量小的场景。（最重要）如果层级多，且数据量大用循环。
	
	5.  解决了哪些问题：
		(1)数据的定义是按递归定义的。（Fibonacci函数：斐波拉契数列）
 		(2)问题解法按递归算法实现。(汉诺塔问题)
 			这类问题虽则本身没有明显的递归结构，但用递归求解比迭代求解更简单，如Hanoi问题。
 		(3)数据的结构形式是按递归定义的。
 			如二叉树、广义表等，由于结构本身固有的递归特性，则它们的操作可递归地描述。
	
	6. 注意事项：
		1. 递归必须 有出口
 		2. 能用循环用循环，不要用递归，因为效率极其低下。
 			为什么效率低下？
 				方法的调用都是创建新栈帧，入栈，而栈层级是有限制的
 			StackOverflowError : 栈内存溢出错误。
 */
public class RecursionTest3 {

	public static void main(String[] args) {
		// 需求：设计方法求1—n的和
		int sum = getSum(10);
		System.out.println(sum);
		
		int sum2 = getSum(1000);
		System.out.println(sum2);
		
	}
	
	/**
	 * 需求：设计方法求1—n的和
	 * 分析：
	 * 	1. 通过数值带入的方式，查找逻辑规律
	 * 	n = 1 getSum(1) = 1
	 * 	n = 2 getSum(2) = 3
	 * 	n = 3 getSum(3) = 6
	 * 	n = 4 getSum(4) = 10
	 * 	n = 5 getSum(5) = 15
	 * 	找出规律
	 * 	getSum(n) = n + getSum(n-1);
	 * 2. 在条件判断中，满足条件调用自己方法
	 * @param n
	 * @return
	 */
	public static int getSum(int n) {
		// 1. 通过数值带入的方式，查找逻辑规律：	将所有的已知条件写出来
		if (n == 1) {
			return 1;
		} else {
			// 2. 通过条件判断（条件/循环）的方式，在满足条件的时候根据规律调用自己的方法。
			return n + getSum(n-1);
		}
	}

}
