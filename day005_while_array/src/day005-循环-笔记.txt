day005-array数组：

1. 循环结构：（掌握）
		概念：就是重复的干一件事
		1. 循环结构，就是重复的干一件事，可以复用代码
		2. 分类：
			条件循环
			死循环【很少使用】
			
		1.1. 先判断，满足条件再干	（掌握）
			while(条件判断){
				循环体（重复干的事）
			}
			
			/*
			 * while执行流程：
			 * 	第1次：1. 初始化条件语句 => 2.条件判断语句 => 3. 循环体 => 4. 循环控制语句
			 * 	第2次：2.条件判断语句 => 3. 循环体 => 4. 循环控制语句
			 * 	第3次：2.条件判断语句 => 3. 循环体 => 4. 循环控制语句
			 * 	...
			 *	最后1次： 2.条件判断语句 
			 */
			
		1.2. 先干一次，再判断，满足条件再干	预执行一次	（掌握）
			do{
				循环体（重复干的事）
			}while(条件判断);//注意分号
			
			/*
			 * do while执行流程：
			 * 	第1次：1. 初始化条件语句 => 3. 循环体 => 4. 循环控制语句
			 * 	第2次：2.条件判断语句 => 3. 循环体 => 4. 循环控制语句
			 * 	第3次：2.条件判断语句 => 3. 循环体 => 4. 循环控制语句
			 * 	...
			 *	最后1次： 2.条件判断语句 
			 */
			例如：
				扫雷、获取连接数据库、远程控制、坦克大战、打飞机游戏
			
		1.3 for循环，可以简单的认为就是while循环的简写	（重点）
			for(1.初始化条件语句;	2.条件判断语句;	4. 循环控制语句){
				3. 循环体
			}
			
			执行流程：（重点）
				第1次：1. 初始化条件语句 => 2.条件判断语句 => 3. 循环体 => 4. 循环控制语句
		 		第2次：2. 条件判断语句 => 3. 循环体 => 4. 循环控制语句
		  		第3次：2. 条件判断语句 => 3. 循环体 => 4. 循环控制语句
		  		...
		 		最后1次： 2.条件判断语句 
				
		1.4 循环注意事项测试：（了解）
			1. while(false){}语法错误
			2. 死循环后面不能紧跟任何代码
				while(true){}
				for(){}
			
			3. while(条件判断);可以不写循环体
			4. for循环
				4.1 for(){}中的条件都可以拿到外部，且可以不写{}
				4.2 for(){}死循环是第二个条件判断不写，就是死循环
				4.3 for(); 可以不写循环体
			
		1.5 使用场景：	（掌握）
			不知道循环次数一般用 while，知道循环次数一般用 for，需要预执行一次的用do{}while();
			
			例如：获取连接数据库、远程控制、坦克大战、打飞机游戏
			
			
		1.6 循环控制语句：（掌握）
				1. break 表示结束当前层循环	（锚点的自己扩展，几乎不用）
				2. continue 表示跳过当前次循环，继续下一次循环
				3. return 表示结束的当前方法
			在以上三个控制语句后，不能紧跟任何代码，因为永远执行不到
			
		1.7 双层for循环，其实，本质外层循环的循环体  是另外一个循环而已	(了解)
			for(1.初始化条件;	2.条件判断;	3. 循环控制语句){
				4. for(5.初始化条件;	6.条件判断;	7. 循环控制语句){
					8. 循环体
				}
			}
			
			执行流程：
				自己画图去研究
			
			总结的规律：（当成是轮子，可以直接使用）
				外层循环执行一次，内层循环执行所有次
				外层循环负责行数，内层负责每一行中列数
				尽量减少嵌套层级
					
			双层for练习
				1.打印九九乘法表	
		
	最核心的是掌握循环的流程（看笔记+画图）


	回顾变量：
		1. 变量声明：
			语法：数据类型 变量名;
			
		2. 变量赋值：
			语法：变量名 = 值;
				
			补充：
				int a,b,c;//不建议，不符合阿里巴巴规范
				
		3. 变量取值：
			变量名
2. 数组：
	1. 概念：就是一堆盒子，同一时间，可以保存多个相同数据类型的数据
	2. 作用：可以解决同时保存多个数据的问题
	3. 使用：		
		3.1 数组声明：
			1. 动态创建：
				语法：数据类型[] 数组名 = new 数据类型[长度];//长度不能为负数，且是int类型 最大就是int最大值
				
			2. 静态创建：
				语法：数据类型[] 数组名 = {值1, 值2, 值3.....};//最常用
				
				
				语法：数据类型[] 数组名 = new 数据类型[]{值1,值2,值3.....};//不常用。了解即可
				
			怎么选择用动态创建还是静态创建？
				根据实际情况确定，知道具体的数据，用静态创建，不知道用动态创建
				
		3.2 数组赋值：
			语法：
				下标、索引、角标都是同一回事
				数组名[下标] = 值;
		
		3.3 数组取值：
			语法：
				数组名[下标];
				
		3.4 数组遍历：
			遍历：就是将数组中每一个元素取出来
				方式1：
					普通for循环	可以将数组元素重新赋值
					
				方式2： 简化遍历数组的过程
				 * 2. 增强for循环: foreach		不能将数组元素重新赋值，因为赋值必须通过下标
					语法：
						for(元素数据类型 变量名 : 数组名){
							变量名//就是每一次获取到的元素
						}
						
				数组遍历使用选择：
					如果要操作某一个具体的元素的时候，用普通for循环，因为操作元素需要通过下标
					其他只是遍历的话，用增强for循环 foreach	
			
		3.5 数组中专业术语：
			1.下标、索引、角标都是同一回事:从0 开始到 长度-1
				即：	第1个元素下标是0
				第2个元素下标是1
				最后一个元素下标是：长度-1
				
			2. 元素：就是数组中装的数据
			3. 长度：就是数组可以装的数据多少个是int类型
				获取数组长度的方式： 数组名.length	
			
	4. 数组注意事项：
		4.1 数组的下标范围是[0,arr.length-1],超过下标范围会报错
			ArrayIndexOutOfBoundsException 数组下标越界异常
		
		4.2 数组动态创建可以分为两步：
			1. int[] arr;//只是声明一个int类型的数组，还没有创建（即，还没有分配内存空间）
			2. arr = new int[长度];//分配内存空间，动态创建数组
			
		4.3 数组静态创建可以分为两步：
			1. int[] arr;//只是声明一个int类型的数组，还没有创建（即，还没有分配内存空间）
			2. arr = new int[]{1,2,43};//分配内存空间，动态创建数组
			不能直接这样写：
				arr = {1,2,43};//语法错误
		
		4.4 数组一旦创建，长度就固定不变了。
			如果长度不够或者长度多了，就需要创建新数组，将原来数组中元素复制到新数组中。	
			 int[] arr = {1,2,43};
			 arr = new int[]{1,43};//开辟新的内存区域，重新创建新的数组
			
		4.5 数组是引用数据类型,直接打印数组名是打印的地址
		4.6 动态创建，没有给数组元素赋值，则系统会分配默认值
			（byte/short/int/long）整数类型默认值：0
			(float、double)小数类型默认值：0.0
			boolean类型:false
			char类型默认值：空字符
		
		4.7 空指针异常：NullPointerException
		4.8 数组声明可以这样，但是不建议
			int arr[] = new int[2];// []在数组名后，不建议
		
	5. 数组遍历：
		1. 普通for循环,根据下标获取每一个元素，可以根据下标操作某一个元素
			例如：
			//因为知道数组长度length，所以用for循环，因为数组元素是通过通过下标获取的，下标是从0开始，所以，循环初始化条件是0
			for (int i = 0; i < arr.length; i++) {
				//通过下标获取每一个元素
				System.out.println(arr[i]);//打印每次循环i对应的元素
			}	
			
		2. 增强for循环: foreach
			语法：
				for(元素数据类型 变量名 : 数组名){
					变量名//就是每一次获取到的元素
				}
				
		数组遍历使用选择：
			如果要操作某一个具体的元素的时候，用普通for循环，因为操作元素需要通过下标
			其他只是遍历的话，用增强for循环 foreach		
				
	6. 扩展（内存图）
		基本类型具体的值在栈帧中	
		引用类型具体的值在堆中	

				
				
				
				
				
				
				