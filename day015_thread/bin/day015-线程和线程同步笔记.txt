day016线程和线程同步笔记

4. 异常类
	之前见过的一次都有哪些？
 *
 *		1. 概念【了解】：就是一种不正常的状态而已。可以简单的认为就是一个标志。告诉程序员这是发生了什么问题，应该怎么解决。
 *			例如：猪肉，看到有一个紫色的章。 
 *
 *		2. 异常分类：【了解】
 *			Throwable 所有错误和异常的基类 【了解】
 *				|
 *				|----Error 错误：我们通过Java代码处理不了的。例如：内存溢出OutOfMemory、网络掉线了
 *				|----Exception 异常 ：我们通过Java代码可以处理的
 *						|---RuntimeException 运行时异常（就是只有在运行的时候，才能出现）
 *									|
 *									|----1. NullPointerException
 *									|----2. ArrayIndexOutOfBoundsException
 *									|----3. ClassCastException【多态】
 *									|----4. NumberFormatException
 *									|----5. IllegalArgumentException 非法参数异常
 *									|----6. StringIndexOutOfBoundsException
 *						|
 *						|---非运行时异常（除了RuntimeException之外的所有的异常都是非运行时异常）主要处理的是 非运行时异常
 							在编译期就必须强制程序员处理的异常。
 *
 *		3. Java底层异常的运行和处理的机制：【了解】
 *			发生异常后，程序先查看是否在该异常发生的地方有处理异常的语法结构，如果有，则会处理异常，然后处理完异常后，
 *			正常向下面执行代码。如果没有，则会向上一级调用者抛出该异常，然后继续查看上一级调用者处，是否有处理异常的结构，
 *			如果有就处理，然后继续向下执行，如果没有，会继续向上一级调用者抛出异常，直到抛出到JVM为止。JVM处理异常的方式
 *			是先打印异常信息到控制台，然后退出JVM。
 *		
 		4. 自定义异常： 命名XxxException （掌握）
			设计步骤：	
				1. 设计一个XxxException 去继承 Exception 类
				2. 通过eclipse工具生成一个随机的序列化号 serialVersionUID（选第2个）
					将鼠标移动到类名上，在弹框中选择第二个
				3. 通过eclipse工具生成一个无参构造和一个String类型参数的构造
					alt+shift+s弹框选择通过SuperClass的方式生成，勾选无参构造和String参数构造即可
					
			使用方式：
				在条件判断语句中，满足条件后，创建一个自定义异常对象，然后
	 *			通过throw关键字抛出,并且同时在方法上也要通过throws
	 *			用在（）后｛｝前抛出，多个异常逗号隔开，顺序无所谓。	
 
 *		5. 处理异常的方式：【重点】只需要会选择就可以了，主要是eclipse工具
 *			方式一：try catch	【背锅式】
 *				try {
 *					异常可能发生的代码
 *				} catch (可能的异常类1 e) {// 当发生异常的时候，JVM会自动根据异常类型，创建一个异常对象，将异常信息保存到对象e中。异常信息通过继承Throwable类中的方法获取
 *					处理异常的操作：
 *					1. 打印异常的信息到控制台；
						// 处理方式1 ：获取异常原因    一般处理后给前台页面返回，给用户提示问题原因 
						String message = e.getMessage();
						System.out.println(message);
						// 2. 处理方式2：打印堆栈跟踪日志  推荐 给程序员看的，帮助程序员定位错误的位置，处理异常
						e.printStackTrace();	
						
						// 3. 处理方式3 ：异常类型和异常原因【了解】
						String str = e.toString();
						System.out.println(str);
						
					2. 可以把异常信息保存到一个文件中，可以持久的存储起来；(IO后才能用)
					 	因为实际项目有可能有很多异常打印到控制台，不能随时关注，这时就需要将日志保存
						
 *				} catch (可能的异常类2 e){// 注意：必须子类异常在上面，父类异常在下面。如果异常没有关系，顺序无所谓。
 *					处理方式同上
 *				} .....
 *				finally {
 *					不管上面的上面的执行情况是怎样的，finally代码永远都会执行
 *					一般只是释放资源，不写业务逻辑代码。
 *					例如，在finally中关流、释放锁等	
 *				}			
 *			
 *				try catch处理方式注意事项：
 *					1. 子类异常在上面，父类异常在下面，平级异常顺序无所谓
 *					2. 不要用一个最大的异常处理，尽量细化异常处理方式，因为不同的异常处理的方式是不同的。
 *
			方式二：	向外在抛出给调用者，就是谁调用谁处理。为了给调用者（其他程序员）一个提示 【甩锅式】
					语法：
						当满足异常抛出条件的时候， 创建一个异常对象，通过关键字throw抛出，
						同时该方法也需要通过throws关键字,用在()后{}前，多个异常逗号隔开，顺序无所谓。
 *		
 *		不知道什么时候try什么时候向外抛出？
 *			不用管那么多，现在只有eclipse工具提示红色错误都要try



1. 线程
	1.1. 进程：简单的理解进程就是一个应用程序
	1.2. 线程: 就是进程的最小执行单位，是一个独立的功能。
	
	1.3. 多线程作用：
			为了利用计算机的多核心优势
 *			提高程序运行效率
 ------------------------------------（重点）--------------------------------------------
 	1.4 多线程使用：（重点）
 		 语法：
 *				1. 继承Thread类	（重点掌握）
 *					步骤：
 *					1. 写一个线程类XxxThread extends Thread类
 *					2. 重写run()方法（该方法是业务方法，启动线程后，会自动执行该方法）
 *					3. 写一个测试类，在测试类中创建线程子类对象，调用对象的start()启动线程
 *						
 *				2. 实现Runnable接口	（重点掌握）	
 *					1. 写一个实现业务类XxxRunnableImpl implements Runnable接口
 *					2. 重写run()方法（该方法是业务方法，启动线程后，会自动执行该方法）
 *					3. 写一个测试类，在测试类中
 *						先创建业务类对象，再创建线程对象，并且将业务类对象作为参数传入线程的构造方法中，
 						调用线程对象的start()启动线程
 *
 *				
 
 	1.5 线程的注意事项：
 		1. 只有start方法才是启动线程，run方法只是在执行方法。
 		2. 以后都用实现Runnable接口的方式，因为Java中单继承多实现，实现的扩展性强
 	
 	1.6 线程的常用方法：(掌握)
 		1. 构造方法：
			Thread() 创建一个新的 Thread对象。  
			Thread(String name) 创建一个新的有指定线程名的 Thread对象。  
			Thread(Runnable target)  将Runnable业务类对象作为参数，创建一个新的 Thread对象。    
			Thread(Runnable target, String name) 将Runnable业务类对象作为参数，创建一个新的有指定线程名的 Thread对象。  
 
 		2. 普通方法：
			1. static Thread currentThread() 返回对当前正在执行的线程对象的引用。  
			2. String getName() 返回此线程的名称。 
			3. void setName(String name) 设置线程对象的名字   
			4. void setPriority(int newPriority)   设置线程对象的优先级
			5. int getPriority()  获取线程的优先级
				1-10，越大优先级越高，执行越早，越小就执行越晚
				5是默认优先级。
				当前线程的优先级与创建线程对象的环境的优先级一致
				
			6. boolean isDaemon() 判断这个线程是否是守护线程。  GC是守护线程
				一个线程的默认状态和创建它的环境线程状态一致	
			
			7. void setDaemon(boolean on) 将当前线程设置为守护线程   
				活跃的线程不能设置为守护线程
				
			8. void join() 等待join线程执行完后，再执行当前线程【理解】
			9. void join(long millis)等待join线程线程死亡最多 millis毫秒。  【理解】
			10. static void sleep(long millis)  阻塞当前线程指定的毫秒数后再执行
				一般用来模拟网络延迟，可以做计时器，还可以做倒计时
				
 	1.7 线程扩展（线程状态、了解）
 		1.7.1、新建（new）：线程对象被创建后就进入了新建状态。如：Thread thread = new Thread();

		1.7.2、就绪状态（Runnable）：也被称为“可执行状态”。线程对象被创建后，其他线程调用了该对象的start()方法，
			从而启动该线程。如：thread.start(); 处于就绪状态的线程随时可能被CPU调度执行。
		
		1.7.3、运行状态（Running）：线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。
		
		1.7.4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权限，暂时停止运行。
			直到线程进入就绪状态，才有机会进入运行状态。阻塞的三种情况：
		
		    1）等待阻塞：通过调用线程的wait()方法，让线程等待某工作的完成。
		
		    2）同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程占用），它会进入同步阻塞状态。
		
		    3）其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。
			当sleep()状态超时、join()等待线程终止或超时、或者I/O处理完毕时，线程重新转入就绪状态。
	
		1.7.5、死亡状态（Dead）：线程执行完了或因异常退出了run()方法，该线程结束生命周期。
 	
 ------------------------------------（重点）--------------------------------------------
 	1.8 线程同步方式：（重点）
 			为什么要线程同步？
				为了保证多线程情况下，数据的安全和逻辑合理性
				
				第一种：悲观锁（自己扩展）
					1. 同步代码块（重点掌握）
						语法：
							synchronized(同步对象) {// 必须是几个线程对象所共享的 => static
								有线程安全问题的代码
							}	
							同步对象可以是：static修饰的对象、字节码、this(实现Runnable接口)
						
					2. 同步方法（重点掌握）
						用synchronized关键字修饰方法即可，在修饰符位置，返回值前面
						如果方法是static修饰的：同步的是 :当前类.class 
						如果方法是非static修饰的：同步的是: this 
						
						如果继承Thread的方式，同步方法的话，就需要将方法改为static修饰，所以说，一般我们不用同步方法
						一般建议继承Thread用同步代码块或者锁机制
						
				第二种：乐观锁（自己扩展）（重点掌握）
					锁机制: Lock接口的实现类ReentrantLock【可重入互斥锁】
						构造方法：
							1. ReentrantLock() 创建一个 ReentrantLock的实例。   不要公平机制。效率高
							2. ReentrantLock(boolean fair) 根据给定的公平政策创建一个 ReentrantLock的实例。 
								 理论上获取锁的几率是相同的
						 class X {
						   private final ReentrantLock lock = new ReentrantLock();
						
						   public void m() { 
						     lock.lock();  // 上锁
						     try {
						       	// 有线程安全问题的代码
						     } finally {
						       lock.unlock();//释放锁
						     }
						   }
						 }
					
					
		7. 同步对象：只要这个对象只有一份
			1. static修饰的对象只有一份，在静态区
			2. 字节码文件 Xxx.class文件只有一份，在元空间【建议使用当前类的字节码文件】
		
		8. 线程同步注意事项：（重点掌握）
			1. 使用选择：
				锁机制效率高且功能更加强大，建议使用
				同步方法简单，如果能够满足性能要求建议使用同步方法
			
			2. 同步对象：必须保证几个线程对象共享的是同一个同步对象（一般使用当前类的字节码文件或者this）
			
			3. 锁原则：最小范围原则，为了保证执行效率
 
 
 
 	1.9 线程扩展2（线程池、线程通信、死锁、以及锁的种类）了解
 
 
 
 