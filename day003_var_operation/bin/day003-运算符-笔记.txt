day004-运算符-笔记

1. 变量（重重点）	
	  1. 变量概念：就是一个盒子（容器），用来装数据的。同一时间只能装一个数据。
	  2. 变量作用：用来装好数据，进行运算处理的。
	  3. 使用：（重点）
	  		1. 声明变量
	  			语法：数据类型 变量名;
	  			例如：int age;//声明一个int类型的变量age(年龄)
	  			
	  		2. 变量赋值： =
	  			语法：变量名 = 值; //=右边的值，赋值给 =左边的变量。注意：必须保证值和变量的数据类型一致
	  			例如：age = 23;//将23赋值给变量age。注意：必须保证值23和变量age的数据类型一致
	  		
	  		3. 变量取值：
	  			语法：变量名;
	  			
	  			使用方式：
	  				1. 直接打印输出
	  				2. 做运算（+，-，*，/....）
	  				3. 赋值给另外的变量
	  				
	  				4. 作为方法参数 使用（先不管。学习方法再用）
	  				
	  4. 注意事项：
			1. 变量特殊类型的使用（掌握）
			1.1. long类型	整数型默认类型是int
				long lon = 1L;//将等号右边的long类型的值1L赋值给等号左边的变量lon
				
			1.2. float类型  浮点型默认类型是double
				float f = 3.14F;
				
			1.3 double类型
				double dou = 3.14;
					
				//科学计数法
				double dou2 = 3.14E2;
				double dou3 = 3.14E-2;
				
			1.4. char类型
				基本使用 （掌握）
				char c = '值';
				
				//以下4种使用作为了解
				//使用方式2： 声明char类型变量赋值为 int值	注意，不能超过char的表示范围
				char c2 = 65;//将65所对应的字符赋值给c2
				
				//char取值范围：[0,65535]
				char c3 = 22000;//将65所对应的字符赋值给c2
				
				//使用方式3： 声明int类型变量赋值为char值
				int i = 'A';//这里是将字符A所对应的int值赋值给变量i
				
				//使用方式4：十六进制的表示
				char c4 = '\u0041';//0041是十进制的65，在字符集中对应的是A字符
				
				//使用方式5：特殊字符的使用
				char c5 = '\'';//打印'
				
				char c6 = '\\';//打印\
				  
2. 变量的分类：(掌握)
	1. 局部变量：
		1. 概念：就是声明位置在方法（()内参数，{}中）中，代码块{}   都是局部变量
		2. 作用：为了辅助完成一个方法的功能（后面讲，先不管）
		3. 特点：
			1. 作用域范围： 声明位置下方，到{}结束，都可以使用局部变量
			2. 局部变量，使用之前，必须有值
		
	2. 成员变量：
		1. 概念：直接声明在类中   都是成员变量
		2. 作用：用来解释这个类中的属性（面向对象重点讲，先不管）
		3. 特点：
			1. 作用域范围： 在整个类中都可以使用
			2. 成员变量，使用之前，如果没有值，则系统会分配一个默认值。
				不同的数据类型默认值不同。
					整数类型默认值：0
					小数类型默认值：0.0
					布尔类型默认值：false
					字符类型默认值：空字符
					
					引用类型默认值：null	
		
3. 就近原则：（理解）
	局部变量和成员变量名字可以相同，因为存放内存区域不同。
	
	局部变量	在内存的栈中
	static修饰的成员变量在 静态区
	s非tatic修饰的成员变量在 堆
	
	当使用一个变量的时候，优先从局部变量中查找，如果找不到，才从类中找成员变量。这就是就近原则		  
				  
4. 类型转换：(掌握)
  		byte  short（char）  int  long  float（单精度）  double（双精度） (只有数值类型才能相互转换)
  		----------------------从左到右精度越来越高---------------------------->
  
  		1. 小转大，都是可以隐式转换  （从左到右）
  
  		2. 大转小，必须强制转换  （从右到左）	强制转换有数据的溢出风险。溢出的时候，会以二进制进位
  			强制转换语法：
  				小的数据类型 小的变量 = (小的数据类型)大的变量/值;		  
  		
  			当int类型的具体的值，向byte、short、char类型转换的时候，只要在其表示范围内，都会隐式转换
  				  
				  
5. 表达式：（掌握）		
	1. 概念：就是一个算术式。 例如： 1 + 1 + 2 * 3
	2. 规律：
			1.当表达式中所有的变量类型小于 int的时候，运算后的结果都会自动提升为int类型
			2.当表达式中有变量类型大于 int的时候，运算后的结果以表达式中精度最高的为主

以后开发中用得多的基本数据类型：int、long、boolean
	float 和 double精度易丢失，后面会用常用类中的BigDecimal类型替代 小数型

6. 运算符（重点）
	6.1 算数运算（Arithmetic Operation）（掌握）
		+ ：
			只有String字符串参与的加法运算，才有拼接功能，在String之前，表示加法运算，之后，才表示连接
		-
		*
		/ ： 不能除0
		 	特殊情况：
				1) 10/3 =3； 
				2) 10.0/3=3.33333…
				3) 0/0
				4) 0.0/0.0  
				  	结果是NaN ,任何的NaN都不等于自己（面试题）
				5) 1.0/0.0   结果：Infinity,表示无穷大
		
		%模（取余）：相当于求余数	10%3 表示求余数1
			作用：1. 求余数 	2. 找一个数的倍数
				3. 可以拆分一个多位的数字
			
		++: 自增（重重点）
			1. 只能作用于一个变量，不能是常量
			2. 变量在前
				a++: 先赋值，再自增
					运算步骤：
						step1：先将a的值赋值给  a++ 这个整体
						step2：再将a的值+1
				
			3. 变量在后
				++a:先自增，再赋值
					运算步骤：
						step1：先将a的值+1
						step2：再将a的值赋值给  a++ 这个整体
				
		--: 自减（规律同自增完全相同）（重重点）
	
	6.2 赋值运算（Assignment Operation）：（掌握）是优先级最低的一种运算，等后边的所有运算完毕后，才执行赋值运算
		+= 累加
		-= 累减
		*=
		/=
		=  
		以下这些符号也是赋值运算符，不重要
		...
		&=
		|=
		^=
		
		赋值运算有强制转换功能，可以避免类型提升.会有溢出风险
		例如：
			byte b = 127;
			
			b += 1; => b = (byte)(b+1);
			b = b + 1;
	
	6.3 比较运算(Compare Operation)：（掌握）结果一定是boolean类型,以后通常配合循环和条件语句使用
		>
		<
		>=
		<=
		
		==:
			1. 比较基本类型，比较的是值是否相等
			例如： 
			int a = 1;
			int b = 1;
			System.out.println(a == b); //true
			
			2. 比较引用类型，比较的是地址是否相等
			
		!=:
			1. 比较基本类型，比较的是值是否不相等
			2. 比较引用类型，比较的是地址是否不相等
		
		instanceof:只能比较引用类型，一般配合条件语句使用(面向对象重点讲，今天不管)
			表示判断一个变量或者值是否属于某一个引用数据类型
			语法：
				值/变量 instanceof 引用数据类型
			例如：
				1.System.out.println("约" instanceof String); 
				
				2.String str = "不约";
				System.out.println(str instanceof String); 
	
	6.4 三目(三元)运算(Binocular Operation)：表示如果x为true，执行y，否则，执行z
		语法： x ? y : z;
		x:是boolean类型值或者boolean表达式。
		y、z:可以是表达式，也可以是值或者变量
		
		如果要接收三目运算的结果，必须要求y和z的类型完全一致
		三目运算可以嵌套使用
		
		例如：
			求两个数中的最大值或者最小值
			int a = 1;
			int b = 2;
			int max = a > b ? a : b;
			
			嵌套使用：(看不懂就用单层的)
			int a = 1;
			int b = 2;
			int c = 3;
			int max = a > b ? (a > c ? a : c) : (b > c ? b : c);
		
	6.5 逻辑运算（Logical Operation）（掌握）逻辑运算两边必须是布尔类型的值或者是表达式
		!: 表示取反，非真即假，非假即真 (操作一个变量/值)
		
		&&:逻辑双与，表示并且，有假即假，有短路功能，没有位运算功能
		
		&:逻辑单与，表示并且，有假即假，没有短路功能，有位运算功能
		
		||:逻辑双或，表示或者，有真即真，有短路功能，没有位运算功能
		
		|:逻辑单或，表示或者，有真即真，没有短路功能，有位运算功能
		
		^:逻辑异或， 同假异真
		
		短路问题：当逻辑运算左边能够确定整个表达式结果值的时候，就会发生短路，不会再计算后面的
		结果了，这样可以提供程序运算效率
		
		例如：
			&&当左边为false时，右边的就短路了
			||当左边为true时，右边的就短路了
			
		以后，逻辑运算都用 && 或者 ||
		
		优先级问题：
			! > &&(&) > ||(|)
			验证：
				true || true && false 
				如果是true，&&优先级高
				如果是false，||优先级高或者相等
	
	6.6 位运算（了解）不用管
		~n:	按位取反
			记住公式：n的按位取反结果是： -(n+1)
			
		&: 按位与，有0即0
			3&5 = 1
			0011  => 3
			0101  => 5
			----&
			0001  => 1
		
		|:按位或，有1即1
			3|5 = 7
			0011  => 3
			0101  => 5
			----|
			0111  => 7
		
		^:按位异或，同0异1		常常用来交换两个变量的值
			3^5 = 6
			0011  => 3
			0101  => 5
			----^
			0110  => 6
			
		m << n: 按位左位移，如果m是正数，右边补0，是负数就补1  相当于*2^n 次方，有溢出风险
			3<<2 = 12	*2^2
			0011  => 3
			---- <<
			1100  => 12		
		
		m >> n: 按位右位移，如果m是正数，左边补0，是负数就补1  相当于/2^n 次方
			3>>2 = 0	/2^2
			0011  => 3
			---- <<
			0000  => 0		
			
		m >>> n: 无符号右位移，不管m是正数还是负数，左边永远补0，这样的话，负数移动后就变成了正数，失去了数学意义
		
	
	
	
	
	
				  