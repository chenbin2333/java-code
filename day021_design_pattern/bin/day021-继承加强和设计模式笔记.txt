day021-继承加强和设计模式笔记

1. 单元测试：（掌握）
	1. 导入包，Junit4包
		选中项目，右键 => Build Path  => Add Library【添加类库】  => 选中Junit
		选中Junit4  => finish
		
	2. 写一个单元测试类，命名方式：XxxTest(测试类没有main方法)
		
	3. 在测试类中，设计测试方法，命名方式：testXxx（）
		在方法上方会自动添加一个@Test注解
		【test + alt + /】
		test方法不能改除了名字之外的任何东西【异常可以不写，但是根据情况判断】
		
	4. 运行，右键run as JUnit方式
		如果是全部执行，直接选中 @Test注解，右键run as JUnit方式
		如果是某一个方法，直接选中方法名，右键run as JUnit方式
		@Before// 预执行注解，每次执行方法前都会执行该注解
		@After// 每次执行方法后都会执行该注解
	
	5. 运行后结果解释：
		绿条：表示成功执行
		红条：表示执行失败
			1. 代码有异常
			2. 执行失败，逻辑异常

	6. 自己扩展（测试类中的断言assert）
	7. 注意事项：
		1. 测试方法全部运行的时候，顺序是不定的
		2. 导包的时候，如果没有发现add library则就选择config
		3. before和after方法不能自动生成，需要自己
	扩展：
		https://www.jianshu.com/p/ae9c837a0af9?nomobile
	
	
2. 工具类：（掌握）
	1. 概念：就是类中只有（类方法、实例方法）方法，就是为了调用方法。
	2. 作用：就是一个轮子
	3. 分类：
		1. 静态的	
			方法全部都是static修饰的，调用方式：类名.方法名(...);
		
		2. 非静态的	
			通过单例模式获取到对象后。就是只有一个对象的类
			方法全部都是非static修饰的，调用方式：对象名.方法名(...);
			
	4. 工具类命名：
		XxxUtil、XxxUtils、XxxTool、XxxTools

		
3. jar 包	（掌握）
	1. 什么是jar包：就是别人封装好的字节码文件
	2. 作用：就是提高开发效率的。使用轮子
	3. 使用：
		3.1 封装jar包	（造轮子）
			step1：选中自己想要封装成jar包的类，右键export导出
				在输入框中输入 jar:
					1. jar File : 普通的jar包，没有main方法(最常用)
						在下面写一个jar包的名字，然后选择生成jar包的路径，finish即可
						
					2. Runnable jar File：可以自己执行的jar包，有main方法		(几乎不用)
						要封装为可以执行的jar包，必须先运行一下当前类。
						然后在下面写一个jar包的名字，然后选择生成jar包的路径，finish即可
				
				在cmd控制台中，切换路径到jar文件所在的目录。
				输入 ：java -jar jar包名.jar
				
			step2：剩下的就是按照 3.1中的步骤使用即可
			
		3.2 使用jar包（掌握）
			step1：在当前项目下，创建一文件夹folder，叫lib
			step2：将jar包复制到当前的lib文件夹中
			step3：将所有的jar包选中右键，build path
				add library
			step4：测试的时候，先将原有的类删除，再在我们代码中通过创建对象或者类名的方式使用即可
			
		注意：
			红色叹号产生原因：项目中使用到的jar包找不到，或者版本错误等问题。
			红色叹号解决方案：如果可以知道是哪一个jar包造成的， 就直接将该jar直接remove，
				重新导入新的jar包。
				如果不知道是哪一个jar包造成的，就全部移除，全部重新导入。
					
			
4. 	Properties资源（配置）文件的解析（重点）
---------------------------------（注意：重点）-------------------------------------
	以后配置文件都要放到项目中的一个或者几个单独的文件夹中，为了好管理。
	该文件夹类型是source folder类型，资源文件夹，eclipse工具会自动编译
---------------------------------------------------------------------------------
		
	传统方式获取流是new创建的，而在web开发中有可能获取不到配置文件，为了避免这种情况，用以下方式获取流：
 
 	1. 通过当前类字节码文件获取流
 		当前类.class.getResourceAsStream("/文件路径/文件名");
 		/:如果是source文件夹，直接写文件名，如果是普通文件夹写文件夹名/文件名
 		
 	2. 通过类加载器的方式 
 		1.同当前类的加载器获取
 			1.当前类.class.getClassLoader();// 获取当前类加载器
 			2.classLoader.getResourceAsStream("文件路径/文件名");//通过类加载器获取流对象,如果是源文件夹，直接文件名
 
 		2.通过当前线程的类加载器获取流
 			1、ClassLoader classLoader = Thread.currentThread().getContextClassLoader();	//获取当前线程类加载器
			2、InputStream is = classLoader.getResourceAsStream("文件路径/文件名");//通过当前线程的类加载器获取流对象,如果是源文件夹，直接文件名
			
		建议用当前线程类的加载器方式获取流，线程安全问题
		
5. 设计模式：(框架中使用，是程序设计的高级思想)
	1. 单例模式：（重点）
 *		1. 概念：设计一个类，这个类只能创建一个对象。（限制创建对象对象数量）
 *
 *		2. 怎么设计？
 *			只有一个对象，说明构造方法不能所以访问，限制了构造方法的使用。=> private 构造方法
 			=> 就需要我们在这个类中创建一个对象，通过get方法的方式给外部返回。
 			
 *		
 *		3. 步骤：
 *			1. 私有化构造方法
 *			2. 在类中创建一个对象，并且用private、static、final修饰
 *				private为了避免在外部直接访问当前对象
 *				static是为了在静态方法中可以返回当前类中的对象
 *				final：可加可不加，加了可以保证不可修改，且提高获取效率
 *
 *			3. 提供一个public修饰的方法getInstance给外部返回一个对象【因为在外部不能通过对象调用方法了，只能是通过类调用方法】
 *
 *		4. 单例模式获取方式：
 *			1. 饿汉模式：预加载模式	（优化方式：静态内部类）
 *				优点：在类加载的时候，就创建好对象放到静态区了，获取对象效率高。线程安全
 *				缺点：类加载效率低，并且static修饰的成员占用资源。
 *
 *			2. 懒汉模式：懒加载模式	(优化方式：双重校验锁)
 *				优点：节省资源，在需要的时候创建对象。
 *				缺点：线程不安全。获取对象的时候，效率低
 *				最简单的线程安全的方式：同步方法，效率低
 *				更好的的线程安全的方式：双重校验锁
 *					
 *			3. 枚举：
 *				public enum Singleton{
					INSTANCE;
				}			
 *
 *		5. 作用：
 *				1. 全局配置文件 
 *				2. 全局日志文件 
 *				3. 节省资源，例如，回收站、资源管理器、游戏单开窗口
 *
 *		6. 使用选择：
 *				一般用饿汉模式，如果有序列化（自己百度扩展）要求，用枚举。
 *
 *		7. 不需要频繁创建对象的时候；不允许多个对象 用单例
 
	2. 装饰者模式：（了解）
		命名方式：XxxDecorator
 * 		装饰者模式指的是在不必改变原类（Input）文件和使用继承的情况下，动态地扩展一个类的功能。
 * 			它是通过创建一个包装对象，也就是装饰来包裹真实的对象。
 * 
 * 			实现步骤 ：通过对原类文件继承，对原有方法功能的基础上，增强新的功能
 * 
 * 		使用场景：
 * 			不必改变原类，并且对原有功能进行加强的时候，就需要用装饰者模式
 	
	3. 适配器模式：（了解）
		适配器类：
 *		命名方式： XxxXxxAdaptor
 *	
 *		解决了两个功能的协同工作。（苹果充电器和华为手机充电的问题）
 *		扩展性强，成本低廉
 *
 *		使用场景：
 			不同的类需要配合完成功能
		https://www.cnblogs.com/luohanguo/p/10334291.html 			
	
	4. 简单工厂模式：（了解）Spring框架中有用到
		命名：产品XxxFactory
		简单工厂模式：（后面可以用反射优化代码）
 *		优点：
 *			1.将生产者和消费者分离（解耦），即创建对象和使用对象的功能分离，便于管理
 *		缺点：
 *			1.扩展性弱，如果添加了新的产品，则需要修改工厂方法
 *
 *		使用场景：
 *			适用于产品数量较少，且不经常改变的情况
 
	
6. ThreadLocal类	（掌握简单使用）：
	 解决了线程安全问题，通过线程隔离有安全问题的数据实现的，底层是通过map保存线程id和值的。
	 线程安全的方式：
	 	1. 线程同步:当需要几个线程对象共享数据的时候，解决安全问题的方案就是线程同步
	 	2. 线程隔离:当需要几个线程对象不需要 共享数据的时候，解决安全问题的方案就是线程隔离看，通过ThreadLocal类完成
	
	
	
	
		