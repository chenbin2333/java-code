package cn.itsource.singleton.hungry;

/**
 *	5. 设计模式：(框架中使用，是程序设计的高级思想)
	1. 单例模式：（重点）
 *		1. 概念：设计一个类，这个类只能创建一个对象。（限制创建对象对象数量）
 *
 *		2. 怎么设计？
 *			只有一个对象，说明构造方法不能所以访问，限制了构造方法的使用。=> private 构造方法
 			=> 就需要我们在这个类中创建一个对象，通过get方法的方式给外部返回。
 			=> get方法必须是类方法，不能是实例方法，因为外部没有对象了。
 			=> 创建对象，不能在类方法中，必须在当前类中创建，即 声明一个实例变量,但是在类方法中又不能访问实例变量，只能
 			访问类变量，所以，这个对象需要用static修饰。
 *		
 *		3. 步骤：
 *			1. 私有化构造方法
 *			2. 在类中创建一个对象，并且用private、static、final修饰
 *				private为了避免在外部直接访问当前对象
 *				static是为了在静态方法中可以返回当前类中的对象
 *				final：可加可不加，加了可以保证不可修改，且提高获取效率
 *
 *			3. 提供一个public修饰的方法getInstance给外部返回一个对象【因为在外部不能通过对象调用方法了，只能是通过类调用方法】
 *
 *		4. 单例模式获取方式：
 *			1. 饿汉模式：预加载模式	（优化方式：静态内部类）
 *				优点：在类加载的时候，就创建好对象放到静态区了，获取对象效率高。线程安全
 *				缺点：类加载效率低，并且static修饰的成员占用资源。
 *
 *			2. 懒汉模式：懒加载模式	(优化方式：双重校验锁)
 *				优点：节省资源，在需要的时候创建对象。
 *				缺点：线程不安全。获取对象的时候，效率低
 *				最简单的线程安全的方式：同步方法，效率低
 *				更好的的线程安全的方式：双重校验锁
 *					
 *			3. 枚举：
 *				public enum Singleton{
					INSTANCE;
				}			
 *
 *		5. 作用：
 *				1. 全局配置文件 
 *				2. 全局日志文件 
 *				3. 节省资源，例如，回收站、资源管理器、游戏单开窗口
 *
 *		6. 使用选择：
 *				一般用饿汉模式，如果有序列化（自己百度扩展）要求，用枚举。
 *
 *		7. 不需要频繁创建对象的时候；不允许多个对象 用单例
 */
public class Singleton {
	/**
	 * 1. 私有化构造方法
	 */
	private Singleton() {}
	
	/**
	 * 2. 在类中创建一个对象，并且用private、static、final修饰
	 *		private为了避免在外部直接访问当前对象
	 *		static是为了在静态方法中可以返回当前类中的对象
	 *		final：可加可不加，加了可以保证不可修改，且提高获取效率
	 */
	private static final Singleton INSTANCE = new Singleton();
	
	/**
	 * 3. 提供一个public修饰的方法getInstance给外部返回一个对象
	 * 【因为在外部不能通过对象调用方法了，只能是通过类调用方法】
	 * @return
	 */
	public static Singleton getInstance() {
		// 创建对象，不能在类方法中，因为每次调用方法，都会创建一个新的对象，不符合要求。必须在当前类中创建
//		Singleton instance = new Singleton();
		return INSTANCE;
	}
}
