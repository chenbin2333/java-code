package cn.itsource.singleton.lazy;

/**
 *	5. 设计模式：(框架中使用，是程序设计的高级思想)
	1. 单例模式：（重点）
 *		1. 概念：设计一个类，这个类只能创建一个对象。（限制创建对象对象数量）
 *
 *		2. 怎么设计？
 *			只有一个对象，说明构造方法不能所以访问，限制了构造方法的使用。=> private 构造方法
 			=> 就需要我们在这个类中创建一个对象，通过get方法的方式给外部返回。
 			=> get方法必须是类方法，不能是实例方法，因为外部没有对象了。
 			=> 创建对象，不能在类方法中，必须在当前类中创建，即 声明一个实例变量,但是在类方法中又不能访问实例变量，只能
 			访问类变量，所以，这个对象需要用static修饰。
 *		
 *		3. 步骤：
 *			1. 私有化构造方法
 *			2. 在类中创建一个对象，并且用private、static、final修饰
 *				private为了避免在外部直接访问当前对象
 *				static是为了在静态方法中可以返回当前类中的对象
 *				final：可加可不加，加了可以保证不可修改，且提高获取效率
 *
 *			3. 提供一个public修饰的方法getInstance给外部返回一个对象【因为在外部不能通过对象调用方法了，只能是通过类调用方法】
 *
 *		4. 单例模式获取方式：
 *			1. 饿汉模式：预加载模式	（优化方式：静态内部类）
 *				优点：在类加载的时候，就创建好对象放到静态区了，获取对象效率高。线程安全
 *				缺点：类加载效率低，并且static修饰的成员占用资源。
 *
 *			2. 懒汉模式：懒加载模式	(优化方式：双重校验锁)
 *				优点：节省资源，在需要的时候创建对象。
 *				缺点：线程不安全。获取对象的时候，效率低
 *				最简单的线程安全的方式：同步方法，效率低
 *				更好的的线程安全的方式：双重校验锁
 *					
 *			3. 枚举：
 *				public enum Singleton{
					INSTANCE;
				}			
 *
 *		5. 作用：
 *				1. 全局配置文件 
 *				2. 全局日志文件 
 *				3. 节省资源，例如，回收站、资源管理器、游戏单开窗口
 *
 *		6. 使用选择：
 *				一般用饿汉模式，如果有序列化（自己百度扩展）要求，用枚举。
 *
 *		7. 不需要频繁创建对象的时候；不允许多个对象 用单例
 */
public class Singleton {
	/**
	 * 1. 私有化构造方法
	 */
	private Singleton() {}
	
	/**
	 * 2. 在类中创建一个对象，并且用private、static、final修饰
	 *		private为了避免在外部直接访问当前对象
	 *		static是为了在静态方法中可以返回当前类中的对象
	 *		不能加final，因为final修饰的类变量要求声明必须同时赋值。
	 */
	private static Singleton instance;
	
	/**
	 * 3. 提供一个public修饰的方法getInstance给外部返回一个对象
	 * 	【因为在外部不能通过对象调用方法了，只能是通过类调用方法】
	 * 	需求：在调用该方法的时候，才创建对象，而不是像饿汉模式上来类加载就创建。
	 * 	通过锁解决线程安全问题。
	 * 	1. 同步方法，但是效率太低了
	 *  2. 优化同步代码块
	 * @return
	 */
//	public static synchronized Singleton getInstance() {
	public static Singleton getInstance() {
		// 再次判断当前instance是否已经创建，如果创建了，就直接获取，提高效率
		if (instance == null) {
			synchronized (Singleton.class) {// 当前类作为同步对象
				// 先判断当前对象是否已经创建，判断方式：instance == null
				if (instance == null) {
					// 创建对象,赋值给instance
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}
