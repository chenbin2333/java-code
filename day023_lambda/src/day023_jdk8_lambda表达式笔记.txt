day024_jdk8_lambda表达式笔记：
lambda：【重点】
	1. 概念：就是对函数式接口匿名内部类的简写
	2. 作用：简化代码【简化为方法形参和方法体】
	3. 使用：
		语法：
			函数式接口  变量名 = (参数1，参数2...) -> {
                  //方法体
         	}
			(参数1，参数2…)表示参数列表；
			->表示连接符；连接符号后是方法体
			{}内部是方法体 
		特点说明：
			普通方法的写法
			1、=右边的类型会根据左边的函数式接口类型自动推断； 
			2、如果形参列表为空，只需保留()； 
			3、如果形参只有1个，()可以省略，只需要参数的名称即可； 
			4、如果执行语句只有1句，且无返回值，{}可以省略，
				若有返回值，则若想省去{}，则必须同时省略return，且执行语句也保证只有1句； 
			5、形参列表的数据类型会自动推断； 
			6、lambda不会生成一个单独的内部类文件； 
			7、lambda表达式若访问了局部变量，则局部变量必须是final的，
			若是局部变量没有加final关键字，系统会自动添加，此后在修改该局部变量，会报错；
			
	4. lambda中方法引用：【掌握】
		https://blog.csdn.net/weixin_42022555/article/details/81943263
		可以看看
	
		4.1. 静态方法引用【掌握】
			语法 ： 类名::静态方法名
			注意事项：
				被引用的静态方法参数列表和函数式接口中抽象方法的参数一致！！
				接口的抽象方法没有返回值，引用的静态方法可以有返回值也可以没有
				接口的抽象方法有返回值，引用的静态方法必须有相同类型的返回值！！
			由于满足抽象参数列表与引用参数列表相同，所以可以写成静态方法引用的格式
			
		4.2. 实例方法引用【掌握】
			语法 ： 对象名::非静态方法名
			注意事项：
				被引用的实例方法参数列表和函数式接口中抽象方法的参数一致！！
				接口的抽象方法没有返回值，引用的实例方法可以有返回值也可以没有
				接口的抽象方法有返回值，引用的实例方法必须有相同类型的返回值！！
		
		4.3. 构造方法引用【掌握】
			语法 ：类名::new
			注意事项：
				被构造方法与函数式接口的抽象方法参数列表一致
			
		4.4. 特定类型的方法引用 【掌握】
			语法 ：类名::非静态方法
			注意事项：
				在抽象方法中，参数作为实例方法调用者，就可以简化
				
		4.5. 数组构造方法引用【了解】
			语法 ：数据类型[]::new
		
		4.6.类中方法调用父类或本类方法引用 【了解】
			语法 ：
				this::方法名
				super::方法名

2. Stream流【重点】
 *		1. 概念：就是java支持的一种流水线式处理数据的方式
 *		2. 作用：Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。
 *			这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 
 			比如筛选， 排序，聚合等。
			聚合操作 类似SQL语句一样的操作， 
					比如filter, map, reduce, find, match, sorted等。
 *
 			
 *		3. 使用：
 *			流的数据来源：
 *					数据源 流的来源。 可以是集合，数组，I/O channel
 					（nio new IO非阻塞式IO）， 产生器generator【Random】 等。Random类是Java获取随机数的类。
 					
 *			获取Stream：方式 Collection体系下都有这两个方法（直接通过集合对象调用方法获取即可）
 *				1. stream() − 为集合创建串行流。【线程是安全的】
				2. parallelStream() − 为集合创建并行流。【底层是多线程处理，线程不安全，可以设置线程。可以解决线程安全】
									【每次运行过程可能不同，但最终结果是相同】
			以后如果数据量大，且业务复杂，用并行，数据量少且业务简单，用串行。
			因为，并行分支fork和join合并也需要很多时间
	
		4. 常用方法：
			1. void forEach(Consumer<? super T> action) 对此流的每个元素执行操作。
			      返回值是void，只能放在流的最后一位
					public interface Consumer<T>是一个函数式接口
					使用方式，lambda，表示接受一个参数，并且处理完后没有返回值。
				  		void accept(T t) 对给定的参数执行此操作。  
			
			2. <R> Stream<R> map(Function<? super T,? extends R> mapper) 
		 		map方法，取出每一个元素操作（运算....）
				Function接口中方法: R apply(T t)
				
			3. long count()获取当前元素个数
			4. Stream<T> limit(long maxSize) 获取一个元素个数是maxSize个的Stream对象
			5. Stream<T> sorted() 元素必须是实现Comparable接口
					返回根据自然顺序排序的流，。  
			   Stream<T> sorted(Comparator<? super T> comparator) 
					返回根据定制顺序排序的流，。

			6. 将Stream流中的元素进行聚合操作
			  	<R,A> R collect(Collector<? super T,A,R> collector)  
			  
			  	获取一个Collector实现类对象方式：通过Collectors工具类中的方法:
					https://blog.csdn.net/sl1992/article/details/98900343
				
			  		将Stream流转换为集合对象
			  			static <T> Collector<T,?,List<T>> toList() 将流中的元素放到一个List集合
					将Stream流中元素按照字符串 拼接
		 				static Collector<CharSequence,?,String> joining(CharSequence delimiter)  
		 			将Stream流中元素分组
		 				static <T,K> Collector<T,?,Map<K,List<T>>> groupingBy(Function<? super T,? extends K> classifier)  	
		 			将Stream流中元素计算
			 			static <T,U,A,R> Collector<T,?,R> mapping
			 				(Function<? super T,? extends U> mapper, Collector<? super U,A,R> downstream)  
		 			将Stream流中元素按照指定业务缩容
		 				static <T> Collector<T,?,Optional<T>> reducing(BinaryOperator<T> op)  	
		 				
		 		例如：		
		  		List<T> list = collect(Collectors.toList());将流中 的元素再转换为集合
		 				
			7. Stream<T> distinct() 将流中元素去重,不保证顺序
			
			8. Stream<T> filter(Predicate<? super T> predicate) 
		 		将流中的元素按照指定的业务过滤，返回满足条件的流对象  
		 			public interface Predicate<T>是函数式接口，
		 			抽象：boolean test(T t)  
		 			
		 	 以下几个方法自己扩展：
		 * 		boolean allMatch(Predicate<? super T> predicate)  
		 * 		<R> Stream<R> flatMap(Function<? super T,? extends Stream<? extends R>> mapper)  
		 * 		Optional<T> reduce(BinaryOperator<T> accumulator)  一定要看
		 * 		T reduce(T identity, BinaryOperator<T> accumulator)  
		https://www.cnblogs.com/owenma/p/12207330.html
		https://blog.csdn.net/qq_33591903/article/details/106645900

3. Optional【掌握】表示可选择的
	Optional类：适用于业务复杂的场景，通常配合Stream中reduce方法使用。
 *		1.概念：处理可能为null对象的容器。
 *		2.作用： 更好的 处理null的情况。
 *		3.常用方法：
 *			1. static <T> Optional<T> ofNullable(T value) 
				如果value是null，则返回一个空的 Optional 。否则返回一个带有  指定值的Optional、
				
			2. T orElse(T other)如果不成立则执行 orElse中的语句 
			
			3. <U> Optional<U> map(Function<? super T,? extends U> mapper) 处理Optional对象
			
			4. boolean isPresent() 返回 true表示Optional中装的对象不为null，否则 false表示为null 。  
			
		4. 扩展：
			https://www.cnblogs.com/zhangboyu/p/7580262.html
			https://blog.csdn.net/qq_35634181/article/details/101109300
			
4. Local【掌握】
	  Local(本地) − 简化了日期时间的处理，没有时区的问题。
	Zoned(时区) − 通过指定的时区处理日期时间。
	新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作
		LocalDate：本地日期
		LocalTime：本地时间
		LocalDateTime：本地日期时间 （建议）
		ZonedDateTime：时区日期时间
		ZonedID
		只要为了解决：
			1. 线程安全问题
			2. 时间单位不统一问题
	 * 	1. 先获取通过静态方法获取对应的对象
	 * 	2. 调用方法				
				
				